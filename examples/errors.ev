package main

fn main() {
    a := go fib(35)
    b := go fib(35)
    c := go fib(35)

    results := await.all(a, b, c) // awaits will implicitly convert values to errors incase of error
}

fn example() {
    a := 5 + "10" // crash the program
    echo a        // we don't make it here

    b := catch => 5 + "10" // returns error
    echo b                 // <error>

    // handle the error
    if b is error {
        echo b.message() // cannot add a value of type `number` & `string`
    }

    // make errors
    return error("this is my new error")
    return error.wrap("failed to do something", b)

    // throw errors
    throw error("this is my new error")
    throw error.wrap("failed to do something", b)
}

/* timeout := go time.wait(30)
    switch result := await {
        case a:
            echo `result -> {result}` // result -> 9227465
        case b:
            echo `result -> {result}` // result -> 9227465
        case c:
            echo `result -> {result}` // result -> 9227465
        case timeout:
            echo "timeout threshold hit!"
    }

    // or
    echo await(a, b, c) // -> [(task, 9227465), (task, 9227465), (task, 9227465)]
    // or
    echo await.values(a, b, c) // -> [9227465, 9227465, 9227465]

    // or
    timeout := go time.wait(30)
    for (task, result) := await(a, b, c, timeout) {
        if task == timeout {
            echo "timeout threshold hit!"
            break
        }
        echo `result -> {result}` // result -> 9227465
    }

    // ok
    for v := [2, 3, 8, 12] {
        echo `{v}`
    }

    // ok
    for i, v := [2, 3, 8, 12] {
        echo `{i} -> {v}`
    } */